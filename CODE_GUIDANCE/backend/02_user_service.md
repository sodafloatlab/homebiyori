# バックエンド学習ガイド: 02. user_service

このドキュメントでは、`user_service` の役割と実装について解説します。
このサービスは、ユーザー情報の登録、取得、更新、削除（CRUD）といった、アプリケーションの根幹をなす機能を担当します。

`health_check_service`と比べて、データベースとの連携が含まれるため、より実践的な内容となります。

## 処理の構成要素

`user_service`は、主に以下のファイルで構成されています。

1.  **`models.py`**: 扱うデータ（ユーザー情報など）の構造をPydanticで定義します。
2.  **`main.py`**: FastAPIを使い、ユーザー情報を操作するためのAPIエンドポイント（`/users`, `/users/{user_id}`など）を定義します。
3.  **`database.py`**: データベース（DynamoDB）との実際のやり取り（データの保存、取得など）を行うロジックを記述します。（今後解説）
4.  **`handler.py`**: `health_check_service`と同様に、LambdaとFastAPIを連携させます。

---

## ファイル解説

### 1. `models.py` - データ構造の設計図

このファイルは、`user_service`で扱うデータの「型」と「ルール」をPydanticモデルとして定義しています。

- **役割**: データベースに保存されるデータや、APIで送受信されるデータの形式を厳密に定めることで、予期せぬエラーを防ぎ、システムの安定性を高めます。

- **学習のポイント**:
    - **データ中心設計**: バックエンド開発では、まずこのように「扱うデータは何か」を定義し、そのデータをどう操作するかを考えるのが基本です。
    - **バリデーション**: `Field`や`@field_validator`を使い、不正なデータ（例: 長すぎるニックネーム）が登録されるのを防ぐ仕組みが、システムの堅牢性に繋がっていることを理解しましょう。

### 2. `main.py` - APIエンドポイントの定義

このファイルは、`user_service`のAPIの「窓口」です。FastAPIを使い、クライアント（フロントエンドなど）からのリクエストを受け付け、適切な処理を呼び出します。

#### `main.py`の主要な構成要素

1.  **インポートと初期設定**: 必要なライブラリや自作モジュールを読み込み、ロガーやデータベースクライアント、FastAPIアプリケーション本体の準備をします。

2.  **ミドルウェア**: 全てのAPIリクエストに対して共通の処理（このサービスではメンテナンスチェック）を強制する「検問所」を設置します。

3.  **認証関数**: リクエストを送信したユーザーを特定するための共通関数（`get_authenticated_user_id`）を定義します。

4.  **APIエンドポイント関数**: `@app.get`や`@app.put`といったデコレータを使い、個別のURLに対応する具体的な処理を記述します。

#### APIエンドポイントの処理フロー解説

##### プロフィール取得: `GET /users/profile`

このAPIは、ログイン中のユーザー自身のプロフィール情報を取得します。

**処理の流れ:**
1.  **認証**: `get_authenticated_user_id`を呼び出し、リクエストの主を特定します。
2.  **DB問合せ**: `database.py`の`get_user_profile`関数を呼び出し、DBからプロフィールデータを取得します。
3.  **新規ユーザー対応**: もしプロフィールが存在しない場合（初回アクセス時など）、エラーとせず、デフォルト値を持つ新しいプロフィールオブジェクトをその場で作成します。
4.  **返却**: 取得または作成したプロフィールオブジェクトを返します。FastAPIがこれをJSONに変換してクライアントに送信します。

##### プロフィール更新: `PUT /users/profile`

このAPIは、ユーザーが自身のプロフィール情報（ニックネームなど）を更新する際に使用します。

**処理の流れ:**
1.  **認証とリクエストボディの検証**: 認証に加え、リクエストボディで送られてきたJSONデータを`UserProfileUpdate`モデルに変換・検証します。
2.  **既存データ取得**: まず、現在のプロフィールをDBから取得します。
3.  **部分更新（マージ）**: `model_copy(update=...)`と`model_dump(exclude_unset=True)`を組み合わせ、クライアントから送られてきた項目**だけ**を安全に更新します。送られてこなかった項目は元の値が維持されます。
4.  **DB保存**: 更新内容を反映したプロフィールデータをDBに保存します。
5.  **返却**: 更新後のプロフィールデータをクライアントに返します。

##### AI設定更新: `PUT /users/ai-preferences`

このAPIは、ユーザーがAIキャラクターの選択や褒めレベルの設定を変更する際に使われます。

**処理のポイント:**
1.  **HTTPメソッドとパス**: `@app.put("/users/ai-preferences")` を使用しています。`PUT`はリソースの更新に使われるため、AI設定の変更に適しています。
2.  **リクエストボディの型**: 引数`ai_preferences: AIPreferences`で、`models.py`で定義された`AIPreferences`モデルを受け取ります。このモデルは、`ai_character`と`praise_level`という2つのフィールドを持ち、それぞれが列挙型（Enum）で定義されているため、不正な値が渡されることを防ぎます。
3.  **既存プロフィールの取得と更新**: `update_user_profile`と同様に、まず`db.get_user_profile(user_id)`で既存のユーザープロフィールを取得します。もしプロフィールが存在すれば、その`existing_profile`オブジェクトの`ai_character`と`praise_level`を、リクエストで受け取った`ai_preferences`の値で直接上書きします。プロフィールが存在しない場合は、`UserProfile`モデルを使って新しいプロフィールオブジェクトを作成し、`user_id`と受け取ったAI設定を初期値として設定します。
4.  **データベースへの保存**: 更新または新規作成した`updated_profile`オブジェクトを`db.save_user_profile(updated_profile)`でデータベースに保存します。
5.  **レスポンス**: `return ai_preferences`として、更新に成功したAI設定をそのままクライアントに返します。`response_model=AIPreferences`が指定されているため、FastAPIがこれをJSONに変換して返します。