# バックエンド学習ガイド: 02. user_service

このドキュメントでは、`user_service` の役割と実装について解説します。
このサービスは、ユーザー情報の登録、取得、更新、削除（CRUD）といった、アプリケーションの根幹をなす機能を担当します。

`health_check_service`と比べて、データベースとの連携が含まれるため、より実践的な内容となります。

## 処理の構成要素

`user_service`は、主に以下のファイルで構成されています。

1.  **`models.py`**: 扱うデータ（ユーザー情報など）の構造をPydanticで定義します。
2.  **`main.py`**: FastAPIを使い、ユーザー情報を操作するためのAPIエンドポイント（`/users`, `/users/{user_id}`など）を定義します。
3.  **`database.py`**: データベース（DynamoDB）との実際のやり取り（データの保存、取得など）を行うロジックを記述します。（今後解説）
4.  **`handler.py`**: `health_check_service`と同様に、LambdaとFastAPIを連携させます。

---

## ファイル解説

### 1. `models.py` - データ構造の設計図

このファイルは、`user_service`で扱うデータの「型」と「ルール」をPydanticモデルとして定義しています。

- **役割**: データベースに保存されるデータや、APIで送受信されるデータの形式を厳密に定めることで、予期せぬエラーを防ぎ、システムの安定性を高めます。

- **学習のポイント**:
    - **データ中心設計**: バックエンド開発では、まずこのように「扱うデータは何か」を定義し、そのデータをどう操作するかを考えるのが基本です。
    - **バリデーション**: `Field`や`@field_validator`を使い、不正なデータ（例: 長すぎるニックネーム）が登録されるのを防ぐ仕組みが、システムの堅牢性に繋がっていることを理解しましょう。

#### Q&A: Pydanticモデルの詳細解説

**Q: `user_id: str = Field(..., description="...")` の `...` はどういう意味ですか？**

**A:** この `...` (三点リーダー、Ellipsisとも呼ばれます)は、Pydanticにおいて**「このフィールドが必須項目である」**ことを示す特別な記法です。

`UserProfile`モデルを作成する際、`user_id`は絶対に省略できず、必ず値を指定しなければならない、という意味になります。もし省略可能なフィールドにしたい場合は、`...` の代わりに `None` やデフォルト値を指定します。（例: `nickname: Optional[str] = Field(None, ...)`）

---

**Q: `Field`の中に `min_length` や `pattern` などを定義するメリットは何ですか？**

**A:** `Field`に関数を渡すことで、単なる型（例: `str`）だけでなく、より厳格なルール（**バリデーション**）を定義できる点に大きなメリットがあります。

```python
user_id: str = Field(
    ...,  # 必須項目
    description="Cognito User Pool sub (UUID形式)", # (1) 説明
    min_length=36,  # (2) 最小・最大文字数
    max_length=36,
    pattern=r"^[0-9a-f]{8}-...",  # (3) 文字列の形式（正規表現）
)
```

1.  **説明(description)**: APIドキュメントにフィールドの説明を自動で追加できます。
2.  **文字数制限(min/max_length)**: 不正に長い、または短いデータが保存されるのを防ぎます。
3.  **パターン(pattern)**: UUIDのような特定のフォーマットに合致しないデータを弾くことができます。

これにより、**不正なデータがシステムに侵入するのを入り口で防ぎ**、プログラムの安定性とセキュリティを大幅に向上させることができます。

---

**Q: `ai_character: AICharacter = Field(AICharacter.TAMA, ...)` のように、`...` の代わりに値を入れるのはなぜですか？**

**A:** これは**「デフォルト値」**を設定するためです。

`Field`の最初の引数に `...` の代わりに具体的な値（この場合は `AICharacter.TAMA`）を入れておくと、APIリクエストなどでこの `ai_character` フィールドが指定されなかった場合に、自動的にその値が設定されます。

これにより、ユーザーが明示的に選択しなくても、システムとしては必ず有効な値（この場合は「たまさん」）が保証されるため、プログラムがより安定して動作します。

---

**Q: `Field`で文字数を制限しているのに、追加で`@field_validator`を使ってチェックする意味はありますか？**

**A:** はい、非常に重要な意味があります。両者は**チェックの役割が全く違う**からです。

| チェック方法 | 担当する役割 | 例えるなら… |
| :--- | :--- | :--- |
| **`Field(...)`** | **構造的なチェック（形式・長さ）** | 「書類の記入欄に文字が収まっているか？」 |
| **`@field_validator`** | **内容的なチェック（ビジネスルール）** | 「書類に書かれた内容が適切か？（NGワードなど）」 |

`Field`の文字数制限は、あくまで文字の「数」しか見ていません。
しかし、ニックネームには、「空白文字だけの登録を禁止する」「不適切な単語（NGワード）を禁止する」といった、**文字の「内容」に関するビジネスルール**が必要です。

`Field`だけではこうした複雑なチェックはできないため、`@field_validator`を使って独自のチェック処理を呼び出し、より高度で安全なバリデーションを実現しています。

---

**Q: `validate_nickname`関数を共通部品として定義しているのに、`models.py`で`@field_validator`をわざわざ使うのはなぜですか？**

**A:** それは**「関心の分離」**という、非常に重要なソフトウェア設計原則に基づいています。両者は意図的に役割を分けています。

| 要素 | 担当する役割（関心事） |
| :--- | :--- |
| **`validate_nickname`関数**<br>(in `validation.py`) | **「ニックネームはどうあるべきか」というビジネスルールそのもの**<br>・この関数はPydanticに依存せず、どこからでも再利用可能。 |
| **`@field_validator`デコレータ**<br>(in `models.py`) | **「`UserProfile`モデルの`nickname`に、あのルールを適用する」という紐付け役**<br>・Pydanticの検証プロセスに、外部の検証ロジックを組み込むための「接着剤」。 |

もし`models.py`の中に検証ロジックをすべて書いてしまうと、他の場所で同じルールを使いたい時にコードが重複してしまいます。

ルールを`validate_nickname`関数として**一箇所に集約**し、`@field_validator`でそれを**呼び出す**形にすることで、**再利用可能**で**保守しやすい**、優れた設計になるのです。

---

**Q: `validate_nickname_field`メソッドの中で`validate_nickname`関数を呼んでいるのに、なぜ`@field_validator`デコレータまで必要なんですか？**

**A:** それは、`@field_validator`デコレータが、私たちが作った検証メソッドを**「Pydanticの自動検証システムに登録する」**という、非常に重要な役割を担っているからです。

私たちがメソッドを定義しただけでは、Pydanticはその存在に気づけません。デコレータは、いわば**「登録係」**です。

`@field_validator("nickname")`と書くことで、クラスが読み込まれた瞬間に「このメソッドを`nickname`フィールド専用の検証関数として登録します！」という宣言が行われます。

この「登録」があって初めて、Pydanticはデータの検証を行う際にこのメソッドを自動で呼び出すことができます。デコレータは、私たちが書いたロジックとフレームワークの仕組みを繋ぐ、**必須の「おまじない」であり「宣言」**なのです。

---

**Q: `model_config`は何のための定義ですか？**

**A:** `model_config`は、**モデル全体に対する設定や指示を書き込む場所**です。個々のフィールドではなく、モデルそのものの振る舞いをカスタマイズします。

```python
model_config = ConfigDict(
    json_encoders={datetime: lambda v: v.isoformat()},
    json_schema_extra={"example": { ... }}
)
```

- **`json_schema_extra`**: APIドキュメントに表示する**具体的なデータサンプル**を定義します。これにより、APIの利用者が使い方を理解しやすくなります。
- **`json_encoders`**: `datetime`のような、そのままではJSONにできないPythonオブジェクトを、**どのように文字列に変換するか**というルールを定義します。これにより、安全なデータ交換が可能になります。

---

**Q: `model_config`にはデコレータが付いていませんが、なぜ機能するのですか？**

**A:** `model_config`が機能するのは、それがPydanticによって特別に認識される**「予約された変数名」**だからです。

フレームワークは、特定の名前の変数やメソッドに特別な意味を持たせることがあります。`model_config`は、「このモデル全体の設定値は、この変数に書かれている」というPydanticとの「お約束」なのです。

- **デコレータ**: 特定の**メソッド**を、フレームワークの**アクション**として登録する場合に使う。
- **予約名**: クラス**全体**に影響する**静的な設定値**を定義する場合に使う。

このように、`model_config`は「アクション」ではなく「設定値」であるため、デコレータではなく予約された変数名を使う設計になっています。

### 2. `main.py` - APIエンドポイントの定義

このファイルは、`user_service`のAPIの「窓口」です。FastAPIを使い、クライアント（フロントエンドなど）からのリクエストを受け付け、適切な処理を呼び出します。

#### `main.py`の主要な構成要素

1.  **インポートと初期設定**: 必要なライブラリや自作モジュールを読み込み、ロガーやデータベースクライアント、FastAPIアプリケーション本体の準備をします。

2.  **ミドルウェア**: 全てのAPIリクエストに対して共通の処理（このサービスではメンテナンスチェック）を強制する「検問所」を設置します。

3.  **認証関数**: リクエストを送信したユーザーを特定するための共通関数（`get_authenticated_user_id`）を定義します。

4.  **APIエンドポイント関数**: `@app.get`や`@app.put`といったデコレータを使い、個別のURLに対応する具体的な処理を記述します。

#### APIエンドポイントの処理フロー解説

##### プロフィール取得: `GET /users/profile`

このAPIは、ログイン中のユーザー自身のプロフィール情報を取得します。

**処理の流れ:**
1.  **認証**: `get_authenticated_user_id`を呼び出し、リクエストの主を特定します。
2.  **DB問合せ**: `database.py`の`get_user_profile`関数を呼び出し、DBからプロフィールデータを取得します。
3.  **新規ユーザー対応**: もしプロフィールが存在しない場合（初回アクセス時など）、エラーとせず、デフォルト値を持つ新しいプロフィールオブジェクトをその場で作成します。
4.  **返却**: 取得または作成したプロフィールオブジェクトを返します。FastAPIがこれをJSONに変換してクライアントに送信します。

##### プロフィール更新: `PUT /users/profile`

このAPIは、ユーザーが自身のプロフィール情報（ニックネームなど）を更新する際に使用します。

**処理の流れ:**
1.  **認証とリクエストボディの検証**: 認証に加え、リクエストボディで送られてきたJSONデータを`UserProfileUpdate`モデルに変換・検証します。
2.  **既存データ取得**: まず、現在のプロフィールをDBから取得します。
3.  **部分更新（マージ）**: `model_copy(update=...)`と`model_dump(exclude_unset=True)`を組み合わせ、クライアントから送られてきた項目**だけ**を安全に更新します。送られてこなかった項目は元の値が維持されます。
4.  **DB保存**: 更新内容を反映したプロフィールデータをDBに保存します。
5.  **返却**: 更新後のプロフィールデータをクライアントに返します。

#### Q&A: `main.py`の技術解説

**Q: `logger.error`で出力したログは、CloudWatchで監視できますか？**

**A:** はい、**可能であり、そのように設計されています。**
このプロジェクトのロガーは、`{"level": "ERROR", "message": "..."}`のようなJSON形式（構造化ログ）でログを出力します。CloudWatchでは、この`level`が`ERROR`であるログを検出するメトリックフィルターを作成し、それをトリガーにアラームを発報して開発者に通知する、という堅牢な監視体制を構築できます。

---

**Q: メンテナンスチェックのミドルウェアは、他のサービスでも共通化すべきでは？**

**A:** その通りです。**共通化すべきであり、技術的にも可能**です。

- **やるべきか？**: 絶対にやるべきです。コードの重複をなくし、保守性を劇的に向上させます。
- **どうやるか？**: `homebiyori_common`レイヤーに`middleware.py`のようなファイルを作り、そこにロジックを移します。各サービスの`main.py`では、その共通ミドルウェアをインポートして`app.middleware("http")(common_middleware)`のように登録するだけです。これはマイクロサービスにおけるベストプラクティスです。

---

**Q: `app.middleware("http")`の`"http"`以外の値はありますか？**

**A:** はい、主に**`"websocket"`**があります。

| プロトコル | 用途 |
| :--- | :--- |
| **`"http"`** | 通常のAPIリクエスト（GET, POSTなど）に対する共通処理。 |
| **`"websocket"`** | チャットのようなリアルタイム双方向通信の接続に対する共通処理。 |

`user_service`ではリアルタイム通信は不要なため、`"http"`のみが使われています。

---

**Q: Cognitoのsub（user_id）をログに出力する際に`****`でマスクする必要はありますか？**

**A:** はい、**マスキングすることは非常に重要なベストプラクティス**です。
Cognitoのsubは、それ自体が個人情報（PII）と見なされる可能性があります。ログに平文で記録すると、万が一ログが漏洩した際に、ユーザーの行動履歴が追跡されるリスクが高まります。

`user_id[:8] + "****"`のように先頭の一部だけを残すことで、開発者はデバッグのために特定のユーザーのログを追跡でき、かつ完全なIDの漏洩は防げるという、**利便性とセキュリティを両立**させています。これは「多層防御」の原則に則った、優れた実装です。
